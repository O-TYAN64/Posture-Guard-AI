<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">

  <link rel="shortcut icon" href="{{ url_for('static', filename='models/favicon.ico') }}">
  <title>Posture Logs</title>

  <!-- Chart.js v4 + time adapter -->
  <script src="https://cdn.jsdelivr.net/npm/chart.js@4"></script>
  <script src="https://cdn.jsdelivr.net/npm/luxon@3/build/global/luxon.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-luxon@1"></script>

  <style>
    /* =========================
       Base
    ========================= */
    html, body { height: 100%; }
    body{
      background:#121212;
      color:#eee;
      font-family:'Courier New', monospace;
      margin:0;
      font-size:0.90em;
    }
    .page{ min-height:100vh; display:flex; flex-direction:column; }

    h1{
      text-align:center;
      margin:10px 0 6px;
      font-size:1.35em;
      text-shadow:1px 1px 3px rgba(0,0,0,0.7);
    }

    /* =========================
       Main chart
    ========================= */
    .chart-container{
      width: min(1100px, 96vw);
      margin: 0 auto;
      height: clamp(240px, 34vh, 380px);
      padding: 0 6px;
    }
    #postureChart{
      width:100% !important;
      height:100% !important;
      display:block;
      font-family:'Courier New', monospace;
      background: rgba(255,255,255,0.02);
      border: 1px solid rgba(255,255,255,0.08);
      border-radius: 10px;
      box-shadow: 0 0 12px rgba(0,0,0,0.35);
    }

    /* =========================
       Navigator
    ========================= */
    .navigator{
      width: min(1100px, 96vw);
      margin: 8px auto 0;
      padding: 10px 12px 12px;
      border-radius: 12px;
      border: 1px solid rgba(255,255,255,0.08);
      background: rgba(255,255,255,0.02);
      box-shadow: 0 0 12px rgba(0,0,0,0.25);
    }
    .nav-top{
      display:flex;
      justify-content:space-between;
      align-items:center;
      gap:10px;
      flex-wrap:wrap;
      margin-bottom: 8px;
    }
    .legend-hint{ color:#9aa0a6; font-size:0.90em; }
    .range-label{
      color:#eaeaea;
      font-size:0.92em;
      padding: 4px 10px;
      border-radius: 999px;
      background: rgba(255,255,255,0.06);
      border: 1px solid rgba(255,255,255,0.10);
    }

    .nav-area{
      position: relative;
      background: rgba(140, 210, 255, 0.18);
      border-radius: 10px;
      overflow:hidden;
      padding: 10px;
    }
    #navChart{
      width:100% !important;
      height:70px !important;
      display:block;
      opacity: 0.9;
    }

    .range-ui.overlay{
      position:absolute;
      inset: 10px;
      border-radius: 10px;
      user-select:none;
      -webkit-user-select:none;
      touch-action: pan-x;
    }
    .range-ui.overlay .dim{
      position:absolute;
      inset:0;
      background: rgba(0,0,0,0.42);
      pointer-events:none;
      z-index:1;
    }
    .range-ui.overlay .dim.left{ left:0; right:auto; width:0; }
    .range-ui.overlay .dim.right{ right:0; left:auto; width:0; }

    .range-ui.overlay .selection{
      position:absolute;
      top:0; bottom:0;
      left:0%;
      width:100%;
      background: rgba(255,255,255,0.07);
      border:none;
      border-radius: 10px;
      z-index:2;
      cursor: grab;
    }
    .range-ui.overlay .selection.dragging{
      cursor: grabbing;
      background: rgba(255,255,255,0.10);
    }
    .range-ui.overlay .knob{
      position:absolute;
      top:50%;
      width: 28px;
      height: 28px;
      transform: translate(-50%, -50%);
      border-radius: 999px;
      background: rgba(220,220,220,0.92);
      border: 1px solid rgba(0,0,0,0.18);
      box-shadow: 0 6px 14px rgba(0,0,0,0.35);
      z-index:3;
      cursor: ew-resize;
    }
    .range-ui.overlay .knob::before{
      content:"";
      position:absolute;
      left:50%;
      top:50%;
      width: 10px;
      height: 14px;
      transform: translate(-50%, -50%);
      background:
        linear-gradient(#6f6f6f,#6f6f6f) left 0 top 0/3px 100% no-repeat,
        linear-gradient(#6f6f6f,#6f6f6f) right 0 top 0/3px 100% no-repeat;
      opacity: 0.95;
    }
    .range-ui.overlay .knob.left{ left:0%; }
    .range-ui.overlay .knob.right{ left:100%; }

    .range-ui.overlay input[type=range]{
      position:absolute;
      inset:0;
      width:100%;
      height:100%;
      opacity:0;
      pointer-events:none;
      -webkit-appearance:none;
      appearance:none;
    }
    .nav-hint{
      color:#888;
      font-size:0.88em;
      margin-top:6px;
    }

    /* =========================
       Table
    ========================= */
    .table-container{
      width: min(1100px, 96vw);
      margin: 10px auto 8px;
      flex: 0 0 auto;
      max-height: clamp(180px, 38vh, 420px);
      overflow:auto;
      border-radius:10px;
      box-shadow:0 0 12px rgba(0,0,0,0.35);
      background:#141414;
    }
    table{ border-collapse: collapse; width:100%; font-variant-numeric: tabular-nums; }
    th, td{
      padding:8px 10px;
      text-align:center;
      font-size:0.95em;
      border-bottom:1px solid rgba(255,255,255,0.08);
      white-space: nowrap;
    }
    th{
      background-color:#1f1f1f;
      color:#fff;
      position: sticky;
      top:0;
      z-index:3;
    }
    tr:nth-child(even){ background-color:#171717; }
    tr:nth-child(odd){ background-color:#1e1e1e; }
    tr:hover{ background-color:rgba(79,195,247,0.10) !important; }

    td.col-time, th.col-time{
      position: sticky;
      left: 0;
      z-index: 4;
      background:#181818;
      box-shadow: 4px 0 8px rgba(0,0,0,0.45);
    }

    /* ✅ pill 基本（ここが抜けると見た目変わりにくい） */
    .pill{
      display:inline-block;
      padding: 4px 12px;
      border-radius: 999px;
      font-weight: 800;
      letter-spacing: .02em;
      border: 1px solid rgba(255,255,255,0.18);
      background: rgba(255,255,255,0.06);
      color: #eee;
    }

    /* ✅ 判定列を確実に色分け（col-judgeを狙う） */
    td.col-judge.good{
      background: rgba(76,175,80,0.08) !important;
      box-shadow: inset 6px 0 0 rgba(76,175,80,0.95) !important;
    }
    td.col-judge.bad{
      background: rgba(244,67,54,0.08) !important;
      box-shadow: inset 6px 0 0 rgba(244,67,54,0.95) !important;
    }

    td.col-judge.good .pill{
      background: rgba(76, 175, 80, 0.50) !important;
      color: #d7ffe8 !important;
      border-color: rgba(76, 175, 80, 0.85) !important;
      text-shadow: 0 0 8px rgba(76, 175, 80, 0.55) !important;
    }
    td.col-judge.bad .pill{
      background: rgba(244, 67, 54, 0.50) !important;
      color: #ffe0e0 !important;
      border-color: rgba(244, 67, 54, 0.85) !important;
      text-shadow: 0 0 8px rgba(244, 67, 54, 0.55) !important;
    }

    /* 行全体も薄く色付けしたい場合（任意） */
    tr.good{ background: linear-gradient(90deg, rgba(76,175,80,0.12), rgba(76,175,80,0.02)); }
    tr.bad { background: linear-gradient(90deg, rgba(244,67,54,0.12), rgba(244,67,54,0.02)); }

    td.metric{ transition:0.2s; }
    td.metric.alert{
      outline:2px solid rgba(255,80,80,0.7);
      border-radius:6px;
      box-shadow:0 0 0 3px rgba(255,80,80,0.25);
    }
    td.metric.alert::after{
      content:" ⚠";
      color:#ff7070;
      font-weight:800;
    }

    .pagination{ text-align:center; margin: 6px 0 10px; }
    .pagination a{ margin: 0 6px; color:#4FC3F7; text-decoration:none; }
    .pagination a.current{ font-weight:bold; text-decoration:underline; }
    .footer{ text-align:center; margin: 0 0 10px; font-size:0.9em; color:#aaa; }

    a{ text-decoration:none; color:#4FC3F7; font-weight:bold; }
    a:hover{ color:#29B6F6; }

    /* =========================
       Selection / range dim
    ========================= */
    tr.selected{ background-color: rgba(79,195,247,0.06) !important; }

    tr.selected td{
      position: relative;
      z-index: 2;
      box-shadow:
        inset 0  2px 0 rgba(79,195,247,0.95),
        inset 0 -2px 0 rgba(79,195,247,0.95);
    }
    tr.selected td:first-child{
      box-shadow:
        inset  2px 0 0 rgba(79,195,247,0.95),
        inset 0  2px 0 rgba(79,195,247,0.95),
        inset 0 -2px 0 rgba(79,195,247,0.95);
    }
    tr.selected td:last-child{
      box-shadow:
        inset -2px 0 0 rgba(79,195,247,0.95),
        inset 0  2px 0 rgba(79,195,247,0.95),
        inset 0 -2px 0 rgba(79,195,247,0.95);
    }
    tr.selected td.col-time{
      z-index: 5;
      background: #181818;
    }

    td.selected-cell{
      position: relative;
      z-index: 6;
      box-shadow: inset 0 0 0 2px rgba(255,255,255,0.55);
      border-radius: 6px;
    }

    td.metric.alert{ position: relative; z-index: 4; }
    td.metric.alert.selected-cell{
      box-shadow:
        inset 0 0 0 2px rgba(255,255,255,0.55),
        inset 0 0 0 4px rgba(255,80,80,0.70);
    }

    tr.outside-range{
      opacity: 0.20;
      filter: grayscale(35%);
    }

    /* =========================
       Login box
    ========================= */
    .login-fixed {
        position:fixed;
        top:24px;
        right: clamp(16px, 6vw, 250px);
        z-index:1000;
    }

    .login-box{
      background:rgba(82, 79, 79, 0.92);
      padding:10px 18px;
      border-radius:14px;
      box-shadow:0 6px 18px rgba(0,0,0,0.20);
      font-size:0.93em;
      backdrop-filter:blur(8px);
    }
  </style>
</head>

<body>
<div class="page">

  {% if current_user.is_authenticated %}
  <div class="login-fixed">
    <section class="login-box">
      <p>ログイン中：{{ current_user.username }}</p>
      {% if current_user.is_admin %}
        <a href="/debug">デバック</a>
      {% endif %}
      <a href="{{ url_for('auth.logout') }}">ログアウト</a>
    </section>
  </div>
  {% endif %}

  <h1>姿勢ログ</h1>

  <div class="chart-container">
    <canvas id="postureChart"></canvas>
  </div>

  <div class="navigator">
    <div class="nav-top">
      <div class="legend-hint">※左右ハンドルで伸縮 / 範囲ドラッグで移動 / 枠外クリックでジャンプ</div>
      <div id="rangeLabel" class="range-label">期間: -</div>
    </div>

    <div class="nav-area">
      <canvas id="navChart"></canvas>

      <div class="range-ui overlay" id="rangeUI">
        <div class="dim left" id="dimL"></div>
        <div class="dim right" id="dimR"></div>

        <div class="selection" id="win">
          <div class="knob left" id="knobL" aria-label="start"></div>
          <div class="knob right" id="knobR" aria-label="end"></div>
        </div>

        <input id="rangeMin" type="range" min="0" max="100" value="0" step="1">
        <input id="rangeMax" type="range" min="0" max="100" value="100" step="1">
      </div>

      <div class="nav-hint">　ハンドル(||)をドラッグで範囲変更できます</div>
    </div>
  </div>

  <div class="table-container">
    <table>
      <tr>
        <th class="col-time">時刻</th>
        <th class="col-judge">判定</th>
        <th>体幹</th>
        <th>首</th>
        <th>肩</th>
      </tr>

      {% for log in logs %}
      {% set judge = (log.judge|lower|trim) %}
      <tr class="{{ judge }}"
          data-iso="{{ log.created_at.strftime('%Y-%m-%dT%H:%M:%S') }}"
          data-torso="{{ log.torso_angle }}"
          data-neck="{{ log.neck_angle }}"
          data-shoulder="{{ log.shoulder_tilt }}">

        <td class="col-time">{{ log.created_at.strftime("%Y-%m-%d %H:%M:%S") }}</td>

        <!-- ✅ 判定列は col-judge を必ず付ける -->
        <td class="col-judge {{ judge }}">
          <span class="pill">{{ log.posture }}</span>
        </td>

        <td class="metric">{{ "%.2f"|format(log.torso_angle) }}</td>
        <td class="metric">{{ "%.2f"|format(log.neck_angle) }}</td>
        <td class="metric">{{ "%.2f"|format(log.shoulder_tilt) }}</td>
      </tr>
      {% endfor %}
    </table>
  </div>

  <div class="pagination">
    {% if page > 1 %}
      <a href="{{ url_for('show_logs', page=page-1) }}">← 前へ</a>
    {% endif %}
    <span class="current">ページ {{ page }}</span>
    {% if has_next %}
      <a href="{{ url_for('show_logs', page=page+1) }}">次へ →</a>
    {% endif %}
  </div>

  <div class="footer">
    <a href="/">ホーム</a>
  </div>

</div>

<script>
/* ============================
   1) データ（ms化して安定）
============================ */
const rawPoints = [
  {% for log in logs %}
  {
    iso: "{{ log.created_at.strftime('%Y-%m-%dT%H:%M:%S') }}",
    torso: {{ log.torso_angle if log.torso_angle is not none else 'null' }},
    neck: {{ log.neck_angle if log.neck_angle is not none else 'null' }},
    shoulder: {{ log.shoulder_tilt if log.shoulder_tilt is not none else 'null' }}
  },
  {% endfor %}
];

const points = rawPoints
  .map(p => ({ ...p, t: luxon.DateTime.fromISO(p.iso).toMillis() }))
  .sort((a,b) => a.t - b.t);

const xs = points.map(p => p.t);
const N = xs.length;

const torsoSeries = points.filter(p => p.torso !== null).map(p => ({ x: p.t, y: p.torso }));
const neckSeries  = points.filter(p => p.neck !== null).map(p => ({ x: p.t, y: p.neck }));
const shSeries    = points.filter(p => p.shoulder !== null).map(p => ({ x: p.t, y: p.shoulder }));

const xMinAll = N ? xs[0] : undefined;
const xMaxAll = N ? xs[N-1] : undefined;

/* ============================
   2) 縦ライン（選択位置）プラグイン
============================ */
let selectedMs = null;

const verticalMarkerPlugin = {
  id: "verticalMarker",
  afterDraw(chart, args, opts){
    const t = opts?.selectedMs;
    if (!t) return;
    const xScale = chart.scales.x;
    if (!xScale) return;

    const min = xScale.min ?? -Infinity;
    const max = xScale.max ??  Infinity;
    if (t < min || t > max) return;

    const x = xScale.getPixelForValue(t);
    const ctx = chart.ctx;

    ctx.save();
    ctx.strokeStyle = "rgba(79,195,247,0.95)";
    ctx.lineWidth = 2;
    ctx.shadowColor = "rgba(79,195,247,0.35)";
    ctx.shadowBlur = 10;

    ctx.beginPath();
    ctx.moveTo(x, chart.chartArea.top);
    ctx.lineTo(x, chart.chartArea.bottom);
    ctx.stroke();

    ctx.shadowBlur = 0;
    ctx.fillStyle = "rgba(79,195,247,1)";
    ctx.beginPath();
    ctx.arc(x, chart.chartArea.top + 6, 3, 0, Math.PI*2);
    ctx.fill();

    ctx.restore();
  }
};

/* ============================
   3) メインチャート
============================ */
const mainChart = new Chart(document.getElementById('postureChart'), {
  type:'line',
    data:{
    datasets:[
      { label:'体幹角度', data:torsoSeries, parsing:false, borderColor:'#4CAF50',
        backgroundColor:'rgba(76,175,80,0.18)', tension:0.25, pointRadius:0, borderWidth:2, spanGaps:true },
      { label:'首角度', data:neckSeries, parsing:false, borderColor:'#FFEB3B',
        backgroundColor:'rgba(255,235,59,0.14)', tension:0.25, pointRadius:0, borderWidth:2, spanGaps:true },
      { label:'肩傾き', data:shSeries, parsing:false, borderColor:'#F44336',
        backgroundColor:'rgba(244,67,54,0.14)', tension:0.25, pointRadius:0, borderWidth:2, spanGaps:true },
    ]
  },
  options:{
    responsive:true,
    maintainAspectRatio:false,
    normalized:true,
    // ▼ 全体の既定フォント（任意）
    font: {
      size: 16,                     // ここを変えると未指定部分に効く
      // family: 'Inter, system-ui, sans-serif',
      // weight: 'normal'
    },
    interaction:{ mode:'index', intersect:false },
    plugins:{
      legend:{
        labels:{
          color:'#eee',
          boxWidth:14, boxHeight:10,
          // ▼ 凡例ラベルのフォントサイズ
          font: { size: 13 }
        }
      },
      tooltip:{
        mode:'index', intersect:false,
        backgroundColor:'rgba(20,20,20,0.92)',
        borderColor:'rgba(255,255,255,0.12)', borderWidth:1,
        titleColor:'#fff', bodyColor:'#eee',
        padding:12,

        // ▼ ツールチップのフォントサイズ（タイトルと本文で別指定）
        titleFont: { size: 15, weight: 'bold' },
        bodyFont:  { size: 15},

        callbacks:{
          title(items){
            const ms = items[0].parsed.x;
            return luxon.DateTime.fromMillis(ms).toFormat("HH:mm:ss");
          }
        }
      },
      decimation:{ enabled:true, algorithm:'lttb', samples:180 },
      verticalMarker:{ selectedMs: null }
    },
    scales:{
      x:{
        type:'time',
        min:xMinAll, max:xMaxAll,
        grid:{ color:'rgba(255,255,255,0.08)' },
        ticks:{
          color:'#eee', maxRotation:0, autoSkip:true,
          // ▼ X軸目盛のフォントサイズ
          font: { size: 12 }
        },
        // （必要なら）軸タイトルのサイズ
        title: { display:true, text:'', font:{ size: 1 } }
      },
      y:{
        grid:{ color:'rgba(255,255,255,0.08)' },
        ticks:{
          color:'#eee',
          // ▼ Y軸目盛のフォントサイズ
          font: { size: 12 }
        },
        // （必要なら）軸タイトルのサイズ
        title: { display:true, text:'', font:{ size: 13 } }
      }
    }
  },
  plugins:[verticalMarkerPlugin]
});

/* ============================
   4) ナビゲータ
============================ */
const navChart = new Chart(document.getElementById('navChart'), {
  type:'line',
  data:{
    datasets:[
      {
        label:'overview',
        data: torsoSeries,
        parsing:false,
        borderColor:'rgba(120, 200, 255, 1)',
        backgroundColor:'rgba(120, 200, 255, 0.22)',
        tension:0.25,
        pointRadius:0,
        borderWidth:2,
        fill:true
      }
    ]
  },
  options:{
    responsive:true,
    maintainAspectRatio:false,
    plugins:{
      legend:{ display:false },
      tooltip:{ enabled:false },
      verticalMarker:{ selectedMs: null }
    },
    scales:{ x:{ type:'time', display:false }, y:{ display:false } }
  },
  plugins:[verticalMarkerPlugin]
});

/* ============================
   5) テーブル⇄グラフ 同期ユーティリティ
============================ */
const tableContainer = document.querySelector(".table-container");
const tableRowsAll = [...document.querySelectorAll("tr[data-iso]")];

const rowEntries = tableRowsAll
  .map(row => ({
    row,
    t: luxon.DateTime.fromISO(row.dataset.iso).toMillis()
  }))
  .sort((a,b) => a.t - b.t);

const rowTimesSorted = rowEntries.map(e => e.t);

function nearestIndex(sortedArr, t){
  let lo = 0, hi = sortedArr.length - 1;
  if (hi < 0) return -1;
  if (t <= sortedArr[0]) return 0;
  if (t >= sortedArr[hi]) return hi;

  while (hi - lo > 1){
    const mid = (lo + hi) >> 1;
    if (sortedArr[mid] <= t) lo = mid;
    else hi = mid;
  }
  return (t - sortedArr[lo] <= sortedArr[hi] - t) ? lo : hi;
}

function clearTableSelection(){
  tableRowsAll.forEach(r => r.classList.remove("selected"));
  document.querySelectorAll("td.selected-cell").forEach(td => td.classList.remove("selected-cell"));
}

function selectTableRowByElement(row, focusCellIndex = null){
  if (!row) return;
  clearTableSelection();

  row.classList.add("selected");

  if (focusCellIndex !== null){
    const metrics = row.querySelectorAll("td.metric");
    if (metrics[focusCellIndex]) metrics[focusCellIndex].classList.add("selected-cell");
  }

  row.scrollIntoView({ behavior:"smooth", block:"center" });
}

function nearestPointIndex(series, t){
  if (!series || !series.length) return -1;
  let lo = 0, hi = series.length - 1;
  if (t <= series[0].x) return 0;
  if (t >= series[hi].x) return hi;

  while (hi - lo > 1){
    const mid = (lo + hi) >> 1;
    if (series[mid].x <= t) lo = mid;
    else hi = mid;
  }
  return (t - series[lo].x <= series[hi].x - t) ? lo : hi;
}

function setChartSelectionByMs(t){
  selectedMs = t;

  mainChart.options.plugins.verticalMarker = { selectedMs: selectedMs };
  navChart.options.plugins.verticalMarker = { selectedMs: selectedMs };

  const ds = mainChart.data.datasets;
  const active = [];

  [0,1,2].forEach(di => {
    const series = ds[di]?.data || [];
    const pi = nearestPointIndex(series, t);
    if (pi >= 0) active.push({ datasetIndex: di, index: pi });
  });

  if (active.length){
    const first = active[0];
    const pt = ds[first.datasetIndex].data[first.index];
    const x = mainChart.scales.x.getPixelForValue(pt.x);
    const y = mainChart.scales.y.getPixelForValue(pt.y);

    mainChart.setActiveElements(active);
    mainChart.tooltip.setActiveElements(active, {x, y});
  }

  mainChart.update("none");
  navChart.update("none");
}

function updateTableRangeDim(minMs, maxMs){
  tableRowsAll.forEach(row => {
    const t = luxon.DateTime.fromISO(row.dataset.iso).toMillis();
    const outside = (t < minMs || t > maxMs);
    row.classList.toggle("outside-range", outside);
  });
}

/* ============================
   6) Navigator UI
============================ */
const rMin = document.getElementById("rangeMin");
const rMax = document.getElementById("rangeMax");
const rangeLabel = document.getElementById("rangeLabel");
const dimL = document.getElementById("dimL");
const dimR = document.getElementById("dimR");
const win  = document.getElementById("win");
const rangeUI = document.getElementById("rangeUI");
const knobL = document.getElementById("knobL");
const knobR = document.getElementById("knobR");

if (N <= 1) {
  rangeLabel.textContent = "期間: データが少ないため選択不可";
} else {
  rMin.min = 0; rMin.max = N - 1; rMin.value = 0;
  rMax.min = 0; rMax.max = N - 1; rMax.value = N - 1;

  const denom = Math.max(1, (N - 1));

  function clampAB(a,b){
    if (a >= b) a = b - 1;
    if (b <= a) b = a + 1;
    a = Math.max(0, Math.min(N - 2, a));
    b = Math.max(1, Math.min(N - 1, b));
    return [a,b];
  }

  function updateNavigatorUI(a,b){
    const leftPct  = (a / denom) * 100;
    const rightPct = (b / denom) * 100;

    dimL.style.width = leftPct + "%";
    dimR.style.width = (100 - rightPct) + "%";

    const rect = rangeUI.getBoundingClientRect();
    const knobRadiusPx = 14;
    const knobRadiusPct = (knobRadiusPx / rect.width) * 100;

    const safeLeft = Math.max(knobRadiusPct, Math.min(100 - knobRadiusPct, leftPct));
    const safeRight = Math.max(knobRadiusPct, Math.min(100 - knobRadiusPct, rightPct));

    knobL.style.left = safeLeft + "%";
    knobR.style.left = safeRight + "%";
  }

  function updateMainRange(a,b){
    const minMs = xs[a];
    const maxMs = xs[b];
    mainChart.options.scales.x.min = minMs;
    mainChart.options.scales.x.max = maxMs;
    mainChart.update('none');

    const s = luxon.DateTime.fromMillis(minMs).toFormat("yyyy-LL-dd HH:mm:ss");
    const e = luxon.DateTime.fromMillis(maxMs).toFormat("yyyy-LL-dd HH:mm:ss");
    rangeLabel.textContent = `期間: ${s} 〜 ${e}`;

    updateTableRangeDim(minMs, maxMs);
  }

  function applyRange(a,b){
    [a,b] = clampAB(a,b);
    rMin.value = a;
    rMax.value = b;
    updateNavigatorUI(a,b);
    updateMainRange(a,b);
  }

  applyRange(0, N - 1);

  let mode = null;
  let startX = 0;
  let startA = 0;
  let startB = 0;
  let pxPerIndex = 1;

  function recalcScale(){
    const rect = rangeUI.getBoundingClientRect();
    pxPerIndex = rect.width / denom;
    return rect;
  }

  function beginDrag(newMode, e){
    mode = newMode;
    startX = e.clientX;
    startA = parseInt(rMin.value, 10);
    startB = parseInt(rMax.value, 10);
    win.classList.add("dragging");
    win.setPointerCapture(e.pointerId);
    recalcScale();
    e.preventDefault();
  }

  function drag(e){
    if (!mode) return;

    const dx = e.clientX - startX;
    const delta = Math.round(dx / pxPerIndex);

    let a = startA;
    let b = startB;

    if (mode === "left") a = startA + delta;
    else if (mode === "right") b = startB + delta;
    else if (mode === "move") {
      const w = startB - startA;
      a = startA + delta;
      b = a + w;
    }

    [a,b] = clampAB(a,b);

    if (mode === "move") {
      const w = startB - startA;
      if (a < 0) { a = 0; b = w; }
      if (b > N - 1) { b = N - 1; a = b - w; }
    }

    applyRange(a,b);
  }

  function endDrag(e){
    if (!mode) return;
    mode = null;
    win.classList.remove("dragging");
    try { win.releasePointerCapture(e.pointerId); } catch {}
  }

  knobL.addEventListener("pointerdown", (e)=>beginDrag("left", e));
  knobR.addEventListener("pointerdown", (e)=>beginDrag("right", e));

  win.addEventListener("pointerdown", (e)=>{
    if (e.target === knobL || e.target === knobR) return;
    beginDrag("move", e);
  });

  win.addEventListener("pointermove", drag);
  win.addEventListener("pointerup", endDrag);
  win.addEventListener("pointercancel", endDrag);

  rangeUI.addEventListener("pointerdown", (e)=>{
    if (e.target === knobL || e.target === knobR || win.contains(e.target)) return;

    const rect = recalcScale();
    const x = e.clientX - rect.left;
    const idx = Math.round((x / rect.width) * denom);

    const a = parseInt(rMin.value, 10);
    const b = parseInt(rMax.value, 10);
    const w = b - a;

    let newA = idx - Math.floor(w / 2);
    let newB = newA + w;

    if (newA < 0) { newA = 0; newB = w; }
    if (newB > N - 1) { newB = N - 1; newA = newB - w; }

    applyRange(newA, newB);
  });

  window.addEventListener("resize", () => {
    applyRange(parseInt(rMin.value, 10), parseInt(rMax.value, 10));
  });
}

/* ============================
   7) グラフクリック → テーブル
============================ */
document.getElementById("postureChart").addEventListener("click", (e) => {
  const els = mainChart.getElementsAtEventForMode(e, "nearest", { intersect:false }, true);
  if (!els.length) return;

  const el = els[0];
  const dp = mainChart.data.datasets[el.datasetIndex].data[el.index];
  if (!dp) return;

  const t = dp.x;
  setChartSelectionByMs(t);

  const ri = nearestIndex(rowTimesSorted, t);
  const row = rowEntries[ri]?.row;

  const focusCell = el.datasetIndex;
  selectTableRowByElement(row, focusCell);
});

/* ============================
   8) テーブルクリック → グラフ
============================ */
tableContainer.addEventListener("click", (e) => {
  const tr = e.target.closest("tr[data-iso]");
  if (!tr) return;

  const t = luxon.DateTime.fromISO(tr.dataset.iso).toMillis();

  let focus = null;
  const td = e.target.closest("td");
  if (td && td.classList.contains("metric")){
    const metrics = [...tr.querySelectorAll("td.metric")];
    focus = metrics.indexOf(td);
  }

  selectTableRowByElement(tr, focus);
  setChartSelectionByMs(t);
});

/* ============================
   9) ヒートマップ（元のロジック）
============================ */
const heatRows = document.querySelectorAll("tr[data-torso]");

function toNums(key){
  return [...heatRows].map(r => parseFloat(r.dataset[key])).filter(Number.isFinite);
}
function quantile(arr, p){
  const a = [...arr].sort((x,y)=>x-y);
  if (!a.length) return NaN;
  const idx = (a.length - 1) * p;
  const lo = Math.floor(idx), hi = Math.ceil(idx);
  if (lo === hi) return a[lo];
  return a[lo] + (a[hi] - a[lo]) * (idx - lo);
}
function heatColorByRange(v, min, max, rgb){
  const t = Math.max(0, Math.min(1, (v - min) / ((max - min) || 1)));
  const a = 0.06 + t * 0.34;
  return `rgba(${rgb[0]},${rgb[1]},${rgb[2]},${a})`;
}
function outOfRange(v, lo, hi){
  return Number.isFinite(v) && (v < lo || v > hi);
}

if (heatRows.length){
  const torsoVals = toNums("torso");
  const neckVals  = toNums("neck");
  const shVals    = toNums("shoulder");

  const R = {
    torso:   [quantile(torsoVals, 0.05), quantile(torsoVals, 0.95)],
    neck:    [quantile(neckVals, 0.05),  quantile(neckVals, 0.95)],
    shoulder:[quantile(shVals, 0.05),    quantile(shVals, 0.95)]
  };

  const M = {
    torso:   [Math.min(...torsoVals), Math.max(...torsoVals)],
    neck:    [Math.min(...neckVals),  Math.max(...neckVals)],
    shoulder:[Math.min(...shVals),    Math.max(...shVals)]
  };

  const C_TORSO = [76,175,80];
  const C_NECK  = [255,235,59];
  const C_SH    = [244,67,54];

  heatRows.forEach(row => {
    const torso = parseFloat(row.dataset.torso);
    const neck  = parseFloat(row.dataset.neck);
    const sh    = parseFloat(row.dataset.shoulder);
    const cells = row.querySelectorAll("td.metric");
    if (cells.length < 3) return;

    if (Number.isFinite(torso)) {
      cells[0].style.background = heatColorByRange(torso, M.torso[0], M.torso[1], C_TORSO);
      if (outOfRange(torso, R.torso[0], R.torso[1])) cells[0].classList.add("alert");
    }
    if (Number.isFinite(neck)) {
      cells[1].style.background = heatColorByRange(neck, M.neck[0], M.neck[1], C_NECK);
      if (outOfRange(neck, R.neck[0], R.neck[1])) cells[1].classList.add("alert");
    }
    if (Number.isFinite(sh)) {
      cells[2].style.background = heatColorByRange(sh, M.shoulder[0], M.shoulder[1], C_SH);
      if (outOfRange(sh, R.shVals?.[0], R.shVals?.[1])) cells[2].classList.add("alert");
      // ↑※もしエラー出たら下の行に置き換え
      // if (outOfRange(sh, R.shoulder[0], R.shoulder[1])) cells[2].classList.add("alert");
    }
  });
}
</script>
</body>
</html>